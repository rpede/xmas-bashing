---
title: Process substitution
date: 2025-12-23
---

Process substitution is another way to chain together input/output of various
commands.
It might sound similar to pipe (`|`) but there is a key difference.

Before I go more in depth on how it works, let me first provide you with an
example.

```sh
diff <(ls -1v ~/Code/project1/) <(ls -1v ~/Code/project2/)
```

`ls -1v` shows files in a folder one item per line.
The `diff` command shows the difference between to files.
The trick is that we are substituting files for processes.
`diff` sees the output from both `ls` commands as files.
It doesn't know that it is working on the output from two commands.
It thinks it's just working with files.

The `<(command)` syntax makes output of _command_ appear as a file.

We can see the path of such process substitution file.

```sh
echo <(echo "Hello")
```

On my machine I got the output `/proc/self/fd/14`.
Where _/proc_ is a virtual file-system that provides information about the
system and processes.

Each time you execute above, you get a different path.
Also, the virtual file disappears again when the command is done.

Here is another example.

```sh
wget -O - https://mirrors.dotsrc.org/archlinux/iso/2025.12.01/archlinux-2025.12.01-x86_64.iso \
| tee >(sha256sum > archlinux.sha256) >(b2sum > archlinux.b2sum) > archlinux.iso
```

The `>(command)` makes output that would normally to go file as input of
_command_.

Effectively we are downloading the Arch Linux ISO to a file (`archlinux.iso`)
and calculating both SHA256 (`archlinux.sha256`) and B2 (`archlinux.b2sum`)
checksums in parallel while downloading.

The command is quite long, so here is a break-down.
`wget` is used to download files.
The `-O -` makes it output to `stdout` instead of saving to a file.
`tee` read from `stdin` and outputs to `stdout` in addition to one or more
files.
Instead of letting `tee` output to files, we are using processes substitution
to output to a sub-command that calculates a checksum.
We then redirect the checksum to a file with `>` as normal.

If you've tried calculating a checksum of a very large file, you know that it
takes a bit of time before you get the result.
That is because your computer has to do a lot of computations to calculate a
result.
The beauty of the above example is that we are calculating two checksums in
parallel while downloading.
So by the time the download is done, we've already calculated the checksums.
